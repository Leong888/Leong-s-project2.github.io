import { defineComponent, ref, computed, watch, nextTick, onUpdated, provide, openBlock, createElementBlock, renderSlot } from 'vue';
import useBaseMapEffect from '../../../hooks/useBaseMapEffect';
import bindEvents from '../../../utils/bindEvents';
import useLifeCycle from '../../../hooks/useLifeCycle';
import { callWhenDifferentValue } from '../../../utils/index';

const __default__ = {
    name: 'BInfoWindow'
};
var script = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__), { props: {
        modelValue: { type: Boolean, required: false, default: false },
        title: { type: String, required: false, default: '' },
        position: { type: Object, required: true },
        width: { type: [Number, null], required: false, default: 0 },
        height: { type: [Number, null], required: false, default: 0 },
        maxWidth: { type: null, required: false, default: 220 },
        offset: { type: Object, required: false, default: () => ({
                x: 0,
                y: 0
            }) },
        enableAutoPan: { type: Boolean, required: false, default: true },
        enableCloseOnClick: { type: Boolean, required: false, default: true },
        onClose: { type: null, required: false },
        onOpen: { type: null, required: false },
        onMaximize: { type: null, required: false },
        onRestore: { type: null, required: false },
        onClickclose: { type: null, required: false }
    }, emits: [
        'initd',
        'unload',
        'close',
        'open',
        'maximize',
        'restore',
        'clickclose',
        'update:modelValue'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const infoWindowContainer = ref();
        const visible = computed({
            get() {
                return props.modelValue;
            },
            set(value) {
                vueEmits('update:modelValue', value);
            }
        });
        const { ready } = useLifeCycle();
        let infoWindow;
        let _map;
        useBaseMapEffect((map) => {
            _map = map;
            const cal = () => {
                infoWindow && map.removeOverlay(infoWindow);
            };
            const init = () => {
                var _a;
                const { title, width, height, enableAutoPan, maxWidth, offset, enableCloseOnClick } = props;
                const options = {
                    width,
                    height,
                    title,
                    maxWidth,
                    enableAutoPan,
                    enableCloseOnClick,
                    offset: new BMapGL.Size(offset.x, offset.y)
                };
                infoWindow = new BMapGL.InfoWindow(((_a = infoWindowContainer.value) === null || _a === void 0 ? void 0 : _a.innerHTML) || '', options);
                infoWindow.addEventListener('close', () => {
                    if (props.modelValue)
                        visible.value = false;
                });
                infoWindow.addEventListener('open', () => {
                    if (!props.modelValue)
                        visible.value = true;
                });
                redraw();
                map.addOverlay(infoWindow);
                bindEvents(props, vueEmits, infoWindow);
            };
            init();
            ready(map, infoWindow);
            // 监听值变化
            watch(() => props.position, callWhenDifferentValue(setPosition), { deep: true });
            watch(() => props.offset, callWhenDifferentValue(setOffset), { deep: true });
            watch(() => props.title, setTitle);
            watch(() => props.width, setWidth);
            watch(() => props.height, setHeight);
            watch(() => props.maxWidth, setMaxWidth);
            watch(() => props.enableAutoPan, setAutoPan);
            watch(() => props.enableCloseOnClick, setCloseOnClick);
            watch(() => props.modelValue, callWhenDifferentValue(() => {
                props.modelValue ? open() : close();
            }));
            if (props.modelValue) {
                // 多个 infoWindow, 显示最后一个实例, 其他实例同步显隐状态
                nextTick(() => {
                    open();
                    nextTick(() => {
                        !infoWindow._visible && (visible.value = false);
                    });
                });
            }
            return cal;
        });
        onUpdated(() => {
            var _a;
            if (infoWindow && infoWindow.isOpen()) {
                setContent(((_a = infoWindowContainer.value) === null || _a === void 0 ? void 0 : _a.innerHTML) || '');
                redraw();
            }
        });
        provide('getOverlayInstance', () => infoWindow);
        function open() {
            const { position } = props;
            _map.openInfoWindow(infoWindow, new BMapGL.Point(position.lng, position.lat));
            visible.value = true;
        }
        function close() {
            infoWindow.hide();
            visible.value = false;
        }
        function redraw() {
            var _a;
            infoWindow.redraw();
            Array.prototype.forEach.call(((_a = infoWindowContainer.value) === null || _a === void 0 ? void 0 : _a.querySelectorAll('img')) || [], (imgEl) => {
                imgEl.onload = () => {
                    infoWindow.redraw();
                };
            });
        }
        function setTitle(title) {
            infoWindow.setTitle(title);
        }
        function setHeight(height) {
            infoWindow.setHeight(height);
        }
        function setWidth(width) {
            infoWindow.setWidth(width);
        }
        function setMaxWidth(maxWidth) {
            infoWindow.setMaxWidth(maxWidth);
        }
        // function setMaximize(maximize: boolean) {
        // 	maximize ? infoWindow.enableMaximize() : infoWindow.disableMaximize()
        // }
        function setAutoPan(autoPan) {
            autoPan ? infoWindow.enableAutoPan() : infoWindow.disableAutoPan();
        }
        function setCloseOnClick(closeOnClick) {
            closeOnClick ? infoWindow.enableCloseOnClick() : infoWindow.disableCloseOnClick();
        }
        function setPosition(position) {
            infoWindow.setPosition(new BMapGL.Point(position.lng, position.lat));
        }
        function setContent(content) {
            infoWindow.setContent(content);
        }
        function setOffset(offset) {
            infoWindow.setOffset(new BMapGL.Size(offset.x, offset.y));
        }
        return (_ctx, _cache) => {
            return (openBlock(), createElementBlock("div", {
                ref_key: "infoWindowContainer",
                ref: infoWindowContainer,
                style: { "display": "none" }
            }, [
                renderSlot(_ctx.$slots, "default")
            ], 512 /* NEED_PATCH */));
        };
    } }));

script.__file = "packages/components/overlay/infowindow/index.vue";

export { script as default };
